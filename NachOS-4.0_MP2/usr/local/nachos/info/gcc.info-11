This is Info file gcc.info, produced by Makeinfo version 1.68 from the
input file ../../gcc-2.95.2/gcc/gcc.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* gcc: (gcc).                  The GNU Compiler Collection.
END-INFO-DIR-ENTRY
   This file documents the use and the internals of the GNU compiler.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Funding
for Free Software" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License" and "Funding for Free Software", and this permission notice,
may be included in translations approved by the Free Software Foundation
instead of in the original English.


File: gcc.info,  Node: Type Attributes,  Next: Alignment,  Prev: Variable Attributes,  Up: C Extensions

Specifying Attributes of Types
==============================

   The keyword `__attribute__' allows you to specify special attributes
of `struct' and `union' types when you define such types.  This keyword
is followed by an attribute specification inside double parentheses.
Three attributes are currently defined for types: `aligned', `packed',
and `transparent_union'.  Other attributes are defined for functions
(*note Function Attributes::.) and for variables (*note Variable
Attributes::.).

   You may also specify any one of these attributes with `__' preceding
and following its keyword.  This allows you to use these attributes in
header files without being concerned about a possible macro of the same
name.  For example, you may use `__aligned__' instead of `aligned'.

   You may specify the `aligned' and `transparent_union' attributes
either in a `typedef' declaration or just past the closing curly brace
of a complete enum, struct or union type *definition* and the `packed'
attribute only past the closing brace of a definition.

   You may also specify attributes between the enum, struct or union
tag and the name of the type rather than after the closing brace.

`aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment (in bytes) for
     variables of the specified type.  For example, the declarations:

          struct S { short f[3]; } __attribute__ ((aligned (8)));
          typedef int more_aligned_int __attribute__ ((aligned (8)));

     force the compiler to insure (as far as it can) that each variable
     whose type is `struct S' or `more_aligned_int' will be allocated
     and aligned *at least* on a 8-byte boundary.  On a Sparc, having
     all variables of type `struct S' aligned to 8-byte boundaries
     allows the compiler to use the `ldd' and `std' (doubleword load and
     store) instructions when copying one variable of type `struct S' to
     another, thus improving run-time efficiency.

     Note that the alignment of any given `struct' or `union' type is
     required by the ANSI C standard to be at least a perfect multiple
     of the lowest common multiple of the alignments of all of the
     members of the `struct' or `union' in question.  This means that
     you *can* effectively adjust the alignment of a `struct' or `union'
     type by attaching an `aligned' attribute to any one of the members
     of such a type, but the notation illustrated in the example above
     is a more obvious, intuitive, and readable way to request the
     compiler to adjust the alignment of an entire `struct' or `union'
     type.

     As in the preceding example, you can explicitly specify the
     alignment (in bytes) that you wish the compiler to use for a given
     `struct' or `union' type.  Alternatively, you can leave out the
     alignment factor and just ask the compiler to align a type to the
     maximum useful alignment for the target machine you are compiling
     for.  For example, you could write:

          struct S { short f[3]; } __attribute__ ((aligned));

     Whenever you leave out the alignment factor in an `aligned'
     attribute specification, the compiler automatically sets the
     alignment for the type to the largest alignment which is ever used
     for any data type on the target machine you are compiling for.
     Doing this can often make copy operations more efficient, because
     the compiler can use whatever instructions copy the biggest chunks
     of memory when performing copies to or from the variables which
     have types that you have aligned this way.

     In the example above, if the size of each `short' is 2 bytes, then
     the size of the entire `struct S' type is 6 bytes.  The smallest
     power of two which is greater than or equal to that is 8, so the
     compiler sets the alignment for the entire `struct S' type to 8
     bytes.

     Note that although you can ask the compiler to select a
     time-efficient alignment for a given type and then declare only
     individual stand-alone objects of that type, the compiler's
     ability to select a time-efficient alignment is primarily useful
     only when you plan to create arrays of variables having the
     relevant (efficiently aligned) type.  If you declare or use arrays
     of variables of an efficiently-aligned type, then it is likely
     that your program will also be doing pointer arithmetic (or
     subscripting, which amounts to the same thing) on pointers to the
     relevant type, and the code that the compiler generates for these
     pointer arithmetic operations will often be more efficient for
     efficiently-aligned types than for other types.

     The `aligned' attribute can only increase the alignment; but you
     can decrease it by specifying `packed' as well.  See below.

     Note that the effectiveness of `aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for variables to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  If your linker is
     only able to align variables up to a maximum of 8 byte alignment,
     then specifying `aligned(16)' in an `__attribute__' will still
     only provide you with 8 byte alignment.  See your linker
     documentation for further information.

`packed'
     This attribute, attached to an `enum', `struct', or `union' type
     definition, specified that the minimum required memory be used to
     represent the type.

     Specifying this attribute for `struct' and `union' types is
     equivalent to specifying the `packed' attribute on each of the
     structure or union members.  Specifying the `-fshort-enums' flag
     on the line is equivalent to specifying the `packed' attribute on
     all `enum' definitions.

     You may only specify this attribute after a closing curly brace on
     an `enum' definition, not in a `typedef' declaration, unless that
     declaration also contains the definition of the `enum'.

`transparent_union'
     This attribute, attached to a `union' type definition, indicates
     that any function parameter having that union type causes calls to
     that function to be treated in a special way.

     First, the argument corresponding to a transparent union type can
     be of any type in the union; no cast is required.  Also, if the
     union contains a pointer type, the corresponding argument can be a
     null pointer constant or a void pointer expression; and if the
     union contains a void pointer type, the corresponding argument can
     be any pointer expression.  If the union member type is a pointer,
     qualifiers like `const' on the referenced type must be respected,
     just as with normal pointer conversions.

     Second, the argument is passed to the function using the calling
     conventions of first member of the transparent union, not the
     calling conventions of the union itself.  All members of the union
     must have the same machine representation; this is necessary for
     this argument passing to work properly.

     Transparent unions are designed for library functions that have
     multiple interfaces for compatibility reasons.  For example,
     suppose the `wait' function must accept either a value of type
     `int *' to comply with Posix, or a value of type `union wait *' to
     comply with the 4.1BSD interface.  If `wait''s parameter were
     `void *', `wait' would accept both kinds of arguments, but it
     would also accept any other pointer type and this would make
     argument type checking less useful.  Instead, `<sys/wait.h>' might
     define the interface as follows:

          typedef union
            {
              int *__ip;
              union wait *__up;
            } wait_status_ptr_t __attribute__ ((__transparent_union__));
          
          pid_t wait (wait_status_ptr_t);

     This interface allows either `int *' or `union wait *' arguments
     to be passed, using the `int *' calling convention.  The program
     can call `wait' with arguments of either type:

          int w1 () { int w; return wait (&w); }
          int w2 () { union wait w; return wait (&w); }

     With this interface, `wait''s implementation might look like this:

          pid_t wait (wait_status_ptr_t p)
          {
            return waitpid (-1, p.__ip, 0);
          }

`unused'
     When attached to a type (including a `union' or a `struct'), this
     attribute means that variables of that type are meant to appear
     possibly unused.  GNU CC will not produce a warning for any
     variables of that type, even if the variable appears to do
     nothing.  This is often the case with lock or thread classes,
     which are usually defined and then not referenced, but contain
     constructors and destructors that have nontrivial bookkeeping
     functions.

   To specify multiple attributes, separate them by commas within the
double parentheses: for example, `__attribute__ ((aligned (16),
packed))'.


File: gcc.info,  Node: Inline,  Next: Extended Asm,  Prev: Alignment,  Up: C Extensions

An Inline Function is As Fast As a Macro
========================================

   By declaring a function `inline', you can direct GNU CC to integrate
that function's code into the code for its callers.  This makes
execution faster by eliminating the function-call overhead; in
addition, if any of the actual argument values are constant, their known
values may permit simplifications at compile time so that not all of the
inline function's code needs to be included.  The effect on code size is
less predictable; object code may be larger or smaller with function
inlining, depending on the particular case.  Inlining of functions is an
optimization and it really "works" only in optimizing compilation.  If
you don't use `-O', no function is really inline.

   To declare a function inline, use the `inline' keyword in its
declaration, like this:

     inline int
     inc (int *a)
     {
       (*a)++;
     }

   (If you are writing a header file to be included in ANSI C programs,
write `__inline__' instead of `inline'.  *Note Alternate Keywords::.)
You can also make all "simple enough" functions inline with the option
`-finline-functions'.

   Note that certain usages in a function definition can make it
unsuitable for inline substitution.  Among these usages are: use of
varargs, use of alloca, use of variable sized data types (*note
Variable Length::.), use of computed goto (*note Labels as Values::.),
use of nonlocal goto, and nested functions (*note Nested Functions::.).
Using `-Winline' will warn when a function marked `inline' could not
be substituted, and will give the reason for the failure.

   Note that in C and Objective C, unlike C++, the `inline' keyword
does not affect the linkage of the function.

   GNU CC automatically inlines member functions defined within the
class body of C++ programs even if they are not explicitly declared
`inline'.  (You can override this with `-fno-default-inline'; *note
Options Controlling C++ Dialect: C++ Dialect Options..)

   When a function is both inline and `static', if all calls to the
function are integrated into the caller, and the function's address is
never used, then the function's own assembler code is never referenced.
In this case, GNU CC does not actually output assembler code for the
function, unless you specify the option `-fkeep-inline-functions'.
Some calls cannot be integrated for various reasons (in particular,
calls that precede the function's definition cannot be integrated, and
neither can recursive calls within the definition).  If there is a
nonintegrated call, then the function is compiled to assembler code as
usual.  The function must also be compiled as usual if the program
refers to its address, because that can't be inlined.

   When an inline function is not `static', then the compiler must
assume that there may be calls from other source files; since a global
symbol can be defined only once in any program, the function must not
be defined in the other source files, so the calls therein cannot be
integrated.  Therefore, a non-`static' inline function is always
compiled on its own in the usual fashion.

   If you specify both `inline' and `extern' in the function
definition, then the definition is used only for inlining.  In no case
is the function compiled on its own, not even if you refer to its
address explicitly.  Such an address becomes an external reference, as
if you had only declared the function, and had not defined it.

   This combination of `inline' and `extern' has almost the effect of a
macro.  The way to use it is to put a function definition in a header
file with these keywords, and put another copy of the definition
(lacking `inline' and `extern') in a library file.  The definition in
the header file will cause most calls to the function to be inlined.
If any uses of the function remain, they will refer to the single copy
in the library.

   GNU C does not inline any functions when not optimizing.  It is not
clear whether it is better to inline or not, in this case, but we found
that a correct implementation when not optimizing was difficult.  So we
did the easy thing, and turned it off.


File: gcc.info,  Node: Extended Asm,  Next: Asm Labels,  Prev: Inline,  Up: C Extensions

Assembler Instructions with C Expression Operands
=================================================

   In an assembler instruction using `asm', you can specify the
operands of the instruction using C expressions.  This means you need
not guess which registers or memory locations will contain the data you
want to use.

   You must specify an assembler instruction template much like what
appears in a machine description, plus an operand constraint string for
each operand.

   For example, here is how to use the 68881's `fsinx' instruction:

     asm ("fsinx %1,%0" : "=f" (result) : "f" (angle));

Here `angle' is the C expression for the input operand while `result'
is that of the output operand.  Each has `"f"' as its operand
constraint, saying that a floating point register is required.  The `='
in `=f' indicates that the operand is an output; all output operands'
constraints must use `='.  The constraints use the same language used
in the machine description (*note Constraints::.).

   Each operand is described by an operand-constraint string followed by
the C expression in parentheses.  A colon separates the assembler
template from the first output operand and another separates the last
output operand from the first input, if any.  Commas separate the
operands within each group.  The total number of operands is limited to
ten or to the maximum number of operands in any instruction pattern in
the machine description, whichever is greater.

   If there are no output operands but there are input operands, you
must place two consecutive colons surrounding the place where the output
operands would go.

   Output operand expressions must be lvalues; the compiler can check
this.  The input operands need not be lvalues.  The compiler cannot
check whether the operands have data types that are reasonable for the
instruction being executed.  It does not parse the assembler instruction
template and does not know what it means or even whether it is valid
assembler input.  The extended `asm' feature is most often used for
machine instructions the compiler itself does not know exist.  If the
output expression cannot be directly addressed (for example, it is a
bit field), your constraint must allow a register.  In that case, GNU CC
will use the register as the output of the `asm', and then store that
register into the output.

   The ordinary output operands must be write-only; GNU CC will assume
that the values in these operands before the instruction are dead and
need not be generated.  Extended asm supports input-output or read-write
operands.  Use the constraint character `+' to indicate such an operand
and list it with the output operands.

   When the constraints for the read-write operand (or the operand in
which only some of the bits are to be changed) allows a register, you
may, as an alternative, logically split its function into two separate
operands, one input operand and one write-only output operand.  The
connection between them is expressed by constraints which say they need
to be in the same location when the instruction executes.  You can use
the same C expression for both operands, or different expressions.  For
example, here we write the (fictitious) `combine' instruction with
`bar' as its read-only source operand and `foo' as its read-write
destination:

     asm ("combine %2,%0" : "=r" (foo) : "0" (foo), "g" (bar));

The constraint `"0"' for operand 1 says that it must occupy the same
location as operand 0.  A digit in constraint is allowed only in an
input operand and it must refer to an output operand.

   Only a digit in the constraint can guarantee that one operand will
be in the same place as another.  The mere fact that `foo' is the value
of both operands is not enough to guarantee that they will be in the
same place in the generated assembler code.  The following would not
work reliably:

     asm ("combine %2,%0" : "=r" (foo) : "r" (foo), "g" (bar));

   Various optimizations or reloading could cause operands 0 and 1 to
be in different registers; GNU CC knows no reason not to do so.  For
example, the compiler might find a copy of the value of `foo' in one
register and use it for operand 1, but generate the output operand 0 in
a different register (copying it afterward to `foo''s own address).  Of
course, since the register for operand 1 is not even mentioned in the
assembler code, the result will not work, but GNU CC can't tell that.

   Some instructions clobber specific hard registers.  To describe this,
write a third colon after the input operands, followed by the names of
the clobbered hard registers (given as strings).  Here is a realistic
example for the VAX:

     asm volatile ("movc3 %0,%1,%2"
                   : /* no outputs */
                   : "g" (from), "g" (to), "g" (count)
                   : "r0", "r1", "r2", "r3", "r4", "r5");

   It is an error for a clobber description to overlap an input or
output operand (for example, an operand describing a register class
with one member, mentioned in the clobber list).  Most notably, it is
invalid to describe that an input operand is modified, but unused as
output.  It has to be specified as an input and output operand anyway.
Note that if there are only unused output operands, you will then also
need to specify `volatile' for the `asm' construct, as described below.

   If you refer to a particular hardware register from the assembler
code, you will probably have to list the register after the third colon
to tell the compiler the register's value is modified.  In some
assemblers, the register names begin with `%'; to produce one `%' in the
assembler code, you must write `%%' in the input.

   If your assembler instruction can alter the condition code register,
add `cc' to the list of clobbered registers.  GNU CC on some machines
represents the condition codes as a specific hardware register; `cc'
serves to name this register.  On other machines, the condition code is
handled differently, and specifying `cc' has no effect.  But it is
valid no matter what the machine.

   If your assembler instruction modifies memory in an unpredictable
fashion, add `memory' to the list of clobbered registers.  This will
cause GNU CC to not keep memory values cached in registers across the
assembler instruction.

   You can put multiple assembler instructions together in a single
`asm' template, separated either with newlines (written as `\n') or
with semicolons if the assembler allows such semicolons.  The GNU
assembler allows semicolons and most Unix assemblers seem to do so.
The input operands are guaranteed not to use any of the clobbered
registers, and neither will the output operands' addresses, so you can
read and write the clobbered registers as many times as you like.  Here
is an example of multiple instructions in a template; it assumes the
subroutine `_foo' accepts arguments in registers 9 and 10:

     asm ("movl %0,r9;movl %1,r10;call _foo"
          : /* no outputs */
          : "g" (from), "g" (to)
          : "r9", "r10");

   Unless an output operand has the `&' constraint modifier, GNU CC may
allocate it in the same register as an unrelated input operand, on the
assumption the inputs are consumed before the outputs are produced.
This assumption may be false if the assembler code actually consists of
more than one instruction.  In such a case, use `&' for each output
operand that may not overlap an input.  *Note Modifiers::.

   If you want to test the condition code produced by an assembler
instruction, you must include a branch and a label in the `asm'
construct, as follows:

     asm ("clr %0;frob %1;beq 0f;mov #1,%0;0:"
          : "g" (result)
          : "g" (input));

This assumes your assembler supports local labels, as the GNU assembler
and most Unix assemblers do.

   Speaking of labels, jumps from one `asm' to another are not
supported.  The compiler's optimizers do not know about these jumps, and
therefore they cannot take account of them when deciding how to
optimize.

   Usually the most convenient way to use these `asm' instructions is to
encapsulate them in macros that look like functions.  For example,

     #define sin(x)       \
     ({ double __value, __arg = (x);   \
        asm ("fsinx %1,%0": "=f" (__value): "f" (__arg));  \
        __value; })

Here the variable `__arg' is used to make sure that the instruction
operates on a proper `double' value, and to accept only those arguments
`x' which can convert automatically to a `double'.

   Another way to make sure the instruction operates on the correct data
type is to use a cast in the `asm'.  This is different from using a
variable `__arg' in that it converts more different types.  For
example, if the desired type were `int', casting the argument to `int'
would accept a pointer with no complaint, while assigning the argument
to an `int' variable named `__arg' would warn about using a pointer
unless the caller explicitly casts it.

   If an `asm' has output operands, GNU CC assumes for optimization
purposes the instruction has no side effects except to change the output
operands.  This does not mean instructions with a side effect cannot be
used, but you must be careful, because the compiler may eliminate them
if the output operands aren't used, or move them out of loops, or
replace two with one if they constitute a common subexpression.  Also,
if your instruction does have a side effect on a variable that otherwise
appears not to change, the old value of the variable may be reused later
if it happens to be found in a register.

   You can prevent an `asm' instruction from being deleted, moved
significantly, or combined, by writing the keyword `volatile' after the
`asm'.  For example:

     #define get_and_set_priority(new)  \
     ({ int __old; \
        asm volatile ("get_and_set_priority %0, %1": "=g" (__old) : "g" (new)); \
        __old; })

If you write an `asm' instruction with no outputs, GNU CC will know the
instruction has side-effects and will not delete the instruction or
move it outside of loops.  If the side-effects of your instruction are
not purely external, but will affect variables in your program in ways
other than reading the inputs and clobbering the specified registers or
memory, you should write the `volatile' keyword to prevent future
versions of GNU CC from moving the instruction around within a core
region.

   An `asm' instruction without any operands or clobbers (and "old
style" `asm') will not be deleted or moved significantly, regardless,
unless it is unreachable, the same wasy as if you had written a
`volatile' keyword.

   Note that even a volatile `asm' instruction can be moved in ways
that appear insignificant to the compiler, such as across jump
instructions.  You can't expect a sequence of volatile `asm'
instructions to remain perfectly consecutive.  If you want consecutive
output, use a single `asm'.

   It is a natural idea to look for a way to give access to the
condition code left by the assembler instruction.  However, when we
attempted to implement this, we found no way to make it work reliably.
The problem is that output operands might need reloading, which would
result in additional following "store" instructions.  On most machines,
these instructions would alter the condition code before there was time
to test it.  This problem doesn't arise for ordinary "test" and
"compare" instructions because they don't have any output operands.

   If you are writing a header file that should be includable in ANSI C
programs, write `__asm__' instead of `asm'.  *Note Alternate Keywords::.

i386 floating point asm operands
--------------------------------

   There are several rules on the usage of stack-like regs in
asm_operands insns.  These rules apply only to the operands that are
stack-like regs:

  1. Given a set of input regs that die in an asm_operands, it is
     necessary to know which are implicitly popped by the asm, and
     which must be explicitly popped by gcc.

     An input reg that is implicitly popped by the asm must be
     explicitly clobbered, unless it is constrained to match an output
     operand.

  2. For any input reg that is implicitly popped by an asm, it is
     necessary to know how to adjust the stack to compensate for the
     pop.  If any non-popped input is closer to the top of the
     reg-stack than the implicitly popped reg, it would not be possible
     to know what the stack looked like -- it's not clear how the rest
     of the stack "slides up".

     All implicitly popped input regs must be closer to the top of the
     reg-stack than any input that is not implicitly popped.

     It is possible that if an input dies in an insn, reload might use
     the input reg for an output reload.  Consider this example:

          asm ("foo" : "=t" (a) : "f" (b));

     This asm says that input B is not popped by the asm, and that the
     asm pushes a result onto the reg-stack, ie, the stack is one
     deeper after the asm than it was before.  But, it is possible that
     reload will think that it can use the same reg for both the input
     and the output, if input B dies in this insn.

     If any input operand uses the `f' constraint, all output reg
     constraints must use the `&' earlyclobber.

     The asm above would be written as

          asm ("foo" : "=&t" (a) : "f" (b));

  3. Some operands need to be in particular places on the stack.  All
     output operands fall in this category -- there is no other way to
     know which regs the outputs appear in unless the user indicates
     this in the constraints.

     Output operands must specifically indicate which reg an output
     appears in after an asm.  `=f' is not allowed: the operand
     constraints must select a class with a single reg.

  4. Output operands may not be "inserted" between existing stack regs.
     Since no 387 opcode uses a read/write operand, all output operands
     are dead before the asm_operands, and are pushed by the
     asm_operands.  It makes no sense to push anywhere but the top of
     the reg-stack.

     Output operands must start at the top of the reg-stack: output
     operands may not "skip" a reg.

  5. Some asm statements may need extra stack space for internal
     calculations.  This can be guaranteed by clobbering stack registers
     unrelated to the inputs and outputs.


   Here are a couple of reasonable asms to want to write.  This asm
takes one input, which is internally popped, and produces two outputs.

     asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));

   This asm takes two inputs, which are popped by the `fyl2xp1' opcode,
and replaces them with one output.  The user must code the `st(1)'
clobber for reg-stack.c to know that `fyl2xp1' pops both inputs.

     asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");


File: gcc.info,  Node: Asm Labels,  Next: Explicit Reg Vars,  Prev: Extended Asm,  Up: C Extensions

Controlling Names Used in Assembler Code
========================================

   You can specify the name to be used in the assembler code for a C
function or variable by writing the `asm' (or `__asm__') keyword after
the declarator as follows:

     int foo asm ("myfoo") = 2;

This specifies that the name to be used for the variable `foo' in the
assembler code should be `myfoo' rather than the usual `_foo'.

   On systems where an underscore is normally prepended to the name of
a C function or variable, this feature allows you to define names for
the linker that do not start with an underscore.

   You cannot use `asm' in this way in a function *definition*; but you
can get the same effect by writing a declaration for the function
before its definition and putting `asm' there, like this:

     extern func () asm ("FUNC");
     
     func (x, y)
          int x, y;
     ...

   It is up to you to make sure that the assembler names you choose do
not conflict with any other assembler symbols.  Also, you must not use a
register name; that would produce completely invalid assembler code.
GNU CC does not as yet have the ability to store static variables in
registers.  Perhaps that will be added.


File: gcc.info,  Node: Explicit Reg Vars,  Next: Alternate Keywords,  Prev: Asm Labels,  Up: C Extensions

Variables in Specified Registers
================================

   GNU C allows you to put a few global variables into specified
hardware registers.  You can also specify the register in which an
ordinary register variable should be allocated.

   * Global register variables reserve registers throughout the program.
     This may be useful in programs such as programming language
     interpreters which have a couple of global variables that are
     accessed very often.

   * Local register variables in specific registers do not reserve the
     registers.  The compiler's data flow analysis is capable of
     determining where the specified registers contain live values, and
     where they are available for other uses.  Stores into local
     register variables may be deleted when they appear to be dead
     according to dataflow analysis.  References to local register
     variables may be deleted or moved or simplified.

     These local variables are sometimes convenient for use with the
     extended `asm' feature (*note Extended Asm::.), if you want to
     write one output of the assembler instruction directly into a
     particular register.  (This will work provided the register you
     specify fits the constraints specified for that operand in the
     `asm'.)

* Menu:

* Global Reg Vars::
* Local Reg Vars::


File: gcc.info,  Node: Global Reg Vars,  Next: Local Reg Vars,  Up: Explicit Reg Vars

Defining Global Register Variables
----------------------------------

   You can define a global register variable in GNU C like this:

     register int *foo asm ("a5");

Here `a5' is the name of the register which should be used.  Choose a
register which is normally saved and restored by function calls on your
machine, so that library routines will not clobber it.

   Naturally the register name is cpu-dependent, so you would need to
conditionalize your program according to cpu type.  The register `a5'
would be a good choice on a 68000 for a variable of pointer type.  On
machines with register windows, be sure to choose a "global" register
that is not affected magically by the function call mechanism.

   In addition, operating systems on one type of cpu may differ in how
they name the registers; then you would need additional conditionals.
For example, some 68000 operating systems call this register `%a5'.

   Eventually there may be a way of asking the compiler to choose a
register automatically, but first we need to figure out how it should
choose and how to enable you to guide the choice.  No solution is
evident.

   Defining a global register variable in a certain register reserves
that register entirely for this use, at least within the current
compilation.  The register will not be allocated for any other purpose
in the functions in the current compilation.  The register will not be
saved and restored by these functions.  Stores into this register are
never deleted even if they would appear to be dead, but references may
be deleted or moved or simplified.

   It is not safe to access the global register variables from signal
handlers, or from more than one thread of control, because the system
library routines may temporarily use the register for other things
(unless you recompile them specially for the task at hand).

   It is not safe for one function that uses a global register variable
to call another such function `foo' by way of a third function `lose'
that was compiled without knowledge of this variable (i.e. in a
different source file in which the variable wasn't declared).  This is
because `lose' might save the register and put some other value there.
For example, you can't expect a global register variable to be
available in the comparison-function that you pass to `qsort', since
`qsort' might have put something else in that register.  (If you are
prepared to recompile `qsort' with the same global register variable,
you can solve this problem.)

   If you want to recompile `qsort' or other source files which do not
actually use your global register variable, so that they will not use
that register for any other purpose, then it suffices to specify the
compiler option `-ffixed-REG'.  You need not actually add a global
register declaration to their source code.

   A function which can alter the value of a global register variable
cannot safely be called from a function compiled without this variable,
because it could clobber the value the caller expects to find there on
return.  Therefore, the function which is the entry point into the part
of the program that uses the global register variable must explicitly
save and restore the value which belongs to its caller.

   On most machines, `longjmp' will restore to each global register
variable the value it had at the time of the `setjmp'.  On some
machines, however, `longjmp' will not change the value of global
register variables.  To be portable, the function that called `setjmp'
should make other arrangements to save the values of the global register
variables, and to restore them in a `longjmp'.  This way, the same
thing will happen regardless of what `longjmp' does.

   All global register variable declarations must precede all function
definitions.  If such a declaration could appear after function
definitions, the declaration would be too late to prevent the register
from being used for other purposes in the preceding functions.

   Global register variables may not have initial values, because an
executable file has no means to supply initial contents for a register.

   On the Sparc, there are reports that g3 ... g7 are suitable
registers, but certain library functions, such as `getwd', as well as
the subroutines for division and remainder, modify g3 and g4.  g1 and
g2 are local temporaries.

   On the 68000, a2 ... a5 should be suitable, as should d2 ... d7.  Of
course, it will not do to use more than a few of those.


File: gcc.info,  Node: Local Reg Vars,  Prev: Global Reg Vars,  Up: Explicit Reg Vars

Specifying Registers for Local Variables
----------------------------------------

   You can define a local register variable with a specified register
like this:

     register int *foo asm ("a5");

Here `a5' is the name of the register which should be used.  Note that
this is the same syntax used for defining global register variables,
but for a local variable it would appear within a function.

   Naturally the register name is cpu-dependent, but this is not a
problem, since specific registers are most often useful with explicit
assembler instructions (*note Extended Asm::.).  Both of these things
generally require that you conditionalize your program according to cpu
type.

   In addition, operating systems on one type of cpu may differ in how
they name the registers; then you would need additional conditionals.
For example, some 68000 operating systems call this register `%a5'.

   Defining such a register variable does not reserve the register; it
remains available for other uses in places where flow control determines
the variable's value is not live.  However, these registers are made
unavailable for use in the reload pass; excessive use of this feature
leaves the compiler too few available registers to compile certain
functions.

   This option does not guarantee that GNU CC will generate code that
has this variable in the register you specify at all times.  You may not
code an explicit reference to this register in an `asm' statement and
assume it will always refer to this variable.

   Stores into local register variables may be deleted when they appear
to be dead according to dataflow analysis.  References to local
register variables may be deleted or moved or simplified.


File: gcc.info,  Node: Alternate Keywords,  Next: Incomplete Enums,  Prev: Explicit Reg Vars,  Up: C Extensions

Alternate Keywords
==================

   The option `-traditional' disables certain keywords; `-ansi'
disables certain others.  This causes trouble when you want to use GNU C
extensions, or ANSI C features, in a general-purpose header file that
should be usable by all programs, including ANSI C programs and
traditional ones.  The keywords `asm', `typeof' and `inline' cannot be
used since they won't work in a program compiled with `-ansi', while
the keywords `const', `volatile', `signed', `typeof' and `inline' won't
work in a program compiled with `-traditional'.

   The way to solve these problems is to put `__' at the beginning and
end of each problematical keyword.  For example, use `__asm__' instead
of `asm', `__const__' instead of `const', and `__inline__' instead of
`inline'.

   Other C compilers won't accept these alternative keywords; if you
want to compile with another compiler, you can define the alternate
keywords as macros to replace them with the customary keywords.  It
looks like this:

     #ifndef __GNUC__
     #define __asm__ asm
     #endif

   `-pedantic' causes warnings for many GNU C extensions.  You can
prevent such warnings within one expression by writing `__extension__'
before the expression.  `__extension__' has no effect aside from this.


File: gcc.info,  Node: Incomplete Enums,  Next: Function Names,  Prev: Alternate Keywords,  Up: C Extensions

Incomplete `enum' Types
=======================

   You can define an `enum' tag without specifying its possible values.
This results in an incomplete type, much like what you get if you write
`struct foo' without describing the elements.  A later declaration
which does specify the possible values completes the type.

   You can't allocate variables or storage using the type while it is
incomplete.  However, you can work with pointers to that type.

   This extension may not be very useful, but it makes the handling of
`enum' more consistent with the way `struct' and `union' are handled.

   This extension is not supported by GNU C++.


File: gcc.info,  Node: Function Names,  Next: Return Address,  Prev: Incomplete Enums,  Up: C Extensions

Function Names as Strings
=========================

   GNU CC predefines two string variables to be the name of the current
function.  The variable `__FUNCTION__' is the name of the function as
it appears in the source.  The variable `__PRETTY_FUNCTION__' is the
name of the function pretty printed in a language specific fashion.

   These names are always the same in a C function, but in a C++
function they may be different.  For example, this program:

     extern "C" {
     extern int printf (char *, ...);
     }
     
     class a {
      public:
       sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };
     
     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = int  a::sub (int)

   These names are not macros: they are predefined string variables.
For example, `#ifdef __FUNCTION__' does not have any special meaning
inside a function, since the preprocessor does not do anything special
with the identifier `__FUNCTION__'.


File: gcc.info,  Node: Return Address,  Next: Other Builtins,  Prev: Function Names,  Up: C Extensions

Getting the Return or Frame Address of a Function
=================================================

   These functions may be used to get information about the callers of a
function.

`__builtin_return_address (LEVEL)'
     This function returns the return address of the current function,
     or of one of its callers.  The LEVEL argument is number of frames
     to scan up the call stack.  A value of `0' yields the return
     address of the current function, a value of `1' yields the return
     address of the caller of the current function, and so forth.

     The LEVEL argument must be a constant integer.

     On some machines it may be impossible to determine the return
     address of any function other than the current one; in such cases,
     or when the top of the stack has been reached, this function will
     return `0'.

     This function should only be used with a non-zero argument for
     debugging purposes.

`__builtin_frame_address (LEVEL)'
     This function is similar to `__builtin_return_address', but it
     returns the address of the function frame rather than the return
     address of the function.  Calling `__builtin_frame_address' with a
     value of `0' yields the frame address of the current function, a
     value of `1' yields the frame address of the caller of the current
     function, and so forth.

     The frame is the area on the stack which holds local variables and
     saved registers.  The frame address is normally the address of the
     first word pushed on to the stack by the function.  However, the
     exact definition depends upon the processor and the calling
     convention.  If the processor has a dedicated frame pointer
     register, and the function has a frame, then
     `__builtin_frame_address' will return the value of the frame
     pointer register.

     The caveats that apply to `__builtin_return_address' apply to this
     function as well.


File: gcc.info,  Node: Other Builtins,  Next: Deprecated Features,  Prev: Return Address,  Up: C Extensions

Other built-in functions provided by GNU CC
===========================================

   GNU CC provides a large number of built-in functions other than the
ones mentioned above.  Some of these are for internal use in the
processing of exceptions or variable-length argument lists and will not
be documented here because they may change from time to time; we do not
recommend general use of these functions.

   The remaining functions are provided for optimization purposes.

   GNU CC includes builtin versions of many of the functions in the
standard C library.  These will always be treated as having the same
meaning as the C library function even if you specify the
`-fno-builtin' (*note C Dialect Options::.) option.  These functions
correspond to the C library functions `alloca', `ffs', `abs', `fabsf',
`fabs', `fabsl', `labs', `memcpy', `memcmp', `strcmp', `strcpy',
`strlen', `sqrtf', `sqrt', `sqrtl', `sinf', `sin', `sinl', `cosf',
`cos', and `cosl'.

   You can use the builtin function `__builtin_constant_p' to determine
if a value is known to be constant at compile-time and hence that GNU
CC can perform constant-folding on expressions involving that value.
The argument of the function is the value to test.  The function
returns the integer 1 if the argument is known to be a compile-time
constant and 0 if it is not known to be a compile-time constant.  A
return of 0 does not indicate that the value is *not* a constant, but
merely that GNU CC cannot prove it is a constant with the specified
value of the `-O' option.

   You would typically use this function in an embedded application
where memory was a critical resource.  If you have some complex
calculation, you may want it to be folded if it involves constants, but
need to call a function if it does not.  For example:

     #define Scale_Value(X)  \
       (__builtin_constant_p (X) ? ((X) * SCALE + OFFSET) : Scale (X))

   You may use this builtin function in either a macro or an inline
function.  However, if you use it in an inlined function and pass an
argument of the function as the argument to the builtin, GNU CC will
never return 1 when you call the inline function with a string constant
or constructor expression (*note Constructors::.) and will not return 1
when you pass a constant numeric value to the inline function unless you
specify the `-O' option.


File: gcc.info,  Node: Deprecated Features,  Prev: Other Builtins,  Up: C Extensions

Deprecated Features
===================

   In the past, the GNU C++ compiler was extended to experiment with new
features, at a time when the C++ language was still evolving. Now that
the C++ standard is complete, some of those features are superceded by
superior alternatives. Using the old features might cause a warning in
some cases that the feature will be dropped in the future. In other
cases, the feature might be gone already.

   While the list below is not exhaustive, it documents some of the
options that are now deprecated:

`-fthis-is-variable'
     In early versions of C++, assignment to this could be used to
     implement application-defined memory allocation. Now, allocation
     functions (`operator new') are the standard-conforming way to
     achieve the same effect.

`-fexternal-templates'
`-falt-external-templates'
     These are two of the many ways for g++ to implement template
     instantiation. *Note Template Instantiation::. The C++ standard
     clearly defines how template definitions have to be organized
     across implementation units. g++ has an implicit instantiation
     mechanism that should work just fine for standard-conforming code.


File: gcc.info,  Node: C++ Extensions,  Next: Gcov,  Prev: C Extensions,  Up: Top

Extensions to the C++ Language
******************************

   The GNU compiler provides these extensions to the C++ language (and
you can also use most of the C language extensions in your C++
programs).  If you want to write code that checks whether these
features are available, you can test for the GNU compiler the same way
as for C programs: check for a predefined macro `__GNUC__'.  You can
also use `__GNUG__' to test specifically for GNU C++ (*note Standard
Predefined Macros: (cpp.info)Standard Predefined.).

* Menu:

* Naming Results::      Giving a name to C++ function return values.
* Min and Max::		C++ Minimum and maximum operators.
* Destructors and Goto:: Goto is safe to use in C++ even when destructors
                           are needed.
* C++ Interface::       You can use a single C++ header file for both
                         declarations and definitions.
* Template Instantiation:: Methods for ensuring that exactly one copy of
                         each needed template instantiation is emitted.
* Bound member functions:: You can extract a function pointer to the
                        method denoted by a `->*' or `.*' expression.
* C++ Signatures::	You can specify abstract types to get subtype
			 polymorphism independent from inheritance.

